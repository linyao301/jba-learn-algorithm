package com.jba.learn.algorithm.bigData;

/**
 * 40亿个非负整数中找到出现两次的数和所有数的中位数
 *
 * <pre>
 *   【题目】
 *   32位无符号整数的范围是0～4 294 967 295，现在有40亿个无符号整数，
 *   可以使用最多1GB的内存，找出所有出现了两次的数。
 * </pre>
 */
public class TwiceNum {

  public void answer() {
    /**
     *对于原问题，可以用 bit map 的方式来表示数出现的情况。
     * 具体地说，是申请一个长度为4_294_967_295×2的bit类型的数组bitArr，
     * 用2个位置表示一个数出现的词频，1B占用8个bit，所以长度为4_294_967_295×2
     * 的bit类型的数组占用1GB空间。怎么使用这个bitArr数组呢？
     * 遍历这40亿个无符号数，如果初次遇到num，
     * 就把bitArr[num*2+1]和bitArr[num*2]设置为01，
     * 如果第二次遇到num，就把bitArr[num*2+1]和bitArr[num*2]设置为10，
     * 如果第三次遇到num，就把bitArr[num*2+1]和 bitArr[num*2]设置为 11。
     * 以后再遇到num，发现此时 bitArr[num*2+1]和bitArr[num*2]已经被设置为11，
     * 就不再做任何设置。遍历完成后，再依次遍历bitArr，如果发现bitArr[i*2+1]
     * 和bitArr[i*2]设置为10，那么i就是出现了两次的数。
     */
  }

  /**
   * 可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？
   */
  public void advance() {
    /**
     *用分区间的方式处理，长度为2MB的无符号整型数组占用的空间为8MB，
     * 所以将区间的数量定为4_294_967_295/2M(4_294_967_295*32/2*4*1024*1024)，
     * 向上取整为2148个区间。第0区间为0～2M-1，第1区间为2M～4M-1，
     * 第i区间为2M×i～2M×（i+1）-1……
     *
     *申请一个长度为 2148 的无符号整型数组 arr[0..2147]，
     * arr[i]表示第 i 区间有多少个数。arr必然小于10MB。
     * 然后遍历 40亿个数，如果遍历到当前数为num，
     * 先看 num落在哪个区间上（num/2M），
     * 然后将对应的进行 arr[num/2M]++操作。
     * 这样遍历下来，就得到了每一个区间的数的出现状况，
     * 通过累加每个区间的出现次数，
     * 就可以找到40亿个数的中位数（也就是第20亿个数）到底落在哪个区间上。
     * 比如，0～K-1区间上数的个数为19.998亿，但是发现当加上第K个区间上数的
     * 个数之后就超过了20亿，那么可以知道第20亿个数是第K区间上的数，
     * 并且可以知道第20亿个数是第K区间上的第0.002亿个数。
     *
     *接下来申请一个长度为2MB的无符号整型数组countArr[0..2M-1]，
     * 占用空间8MB。然后遍历 40 亿个数，此时只关心处在第 K 区间的数记为
     * numi，其他的数省略，然后将countArr[numi-K*2M]++，
     * 也就是只对第K区间的数做频率统计。这次遍历完40亿个数之后，
     * 就得到了第K区间的词频统计结果countArr，
     * 最后只在第K区间上找到第0.002亿个数即可。
     */
  }

}
